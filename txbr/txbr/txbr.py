import os
import os.path
import multiprocessing
import numpy
import modl
import mrc
import utilities
import util

from psutil import NUM_CPUS as PROCESS_POOL_SIZE
from txbrconf import *

PROCESS_POOL_SIZE = max(PROCESS_POOL_SIZE,20)

def __rescale_proj_task__( scale_tf, projection, scaling_fn, scale_inv_tf ):
    """
    A unit task defined to rescale a projection
    """

    projection_ = scale_tf.compose(projection.compose(scale_inv_tf))
    scaling_fn_ = scaling_fn.compose(scale_inv_tf)

    return (projection_,scaling_fn_)

def __rescale_proj_task_star__( args ):
    """
    A wrapper to the *__rescale_proj_task__* function that takes a singe list argument
    (for multiprocessing purpose)
    """

    return __rescale_proj_task__(*args)



class TxBRproject:
    '''A TxBR project class.'''

    def __init__( self, directory, basenames, work_directory=None, input=INPUT, bin=None ):
        """Constructor for the project"""

        if type(basenames).__name__=='str':
            basenames = basenames.split(',')

        self.directory = directory
        self.basename, self.extensions = utilities.extract_series_name(basenames)
        
        # self.extensions does not necessarly contains info on whole series
        # Its informations is generated by only looking at the name semantic
        
        log.info( "Initialize TxBR project: (%s,%s) %s" %(self.directory,self.basename,str(self.extensions)) )
        
        if work_directory==None:
            self.work_directory = directory
        else:
            self.work_directory = work_directory
            loadConfig(work_directory)
            
        if not os.path.exists(self.work_directory): # Eventually create the work directory
            os.mkdir(self.work_directory)

        self.nx = numpy.nan
        self.ny = numpy.nan

        self.setBinFactor( bin )

        # Initialize different Reconstruction and TxBRSeries objects
                
        self.series = []
        self.available_series = {}  # Contains all possible series ( from file directories)
        self.reconstruction = Reconstruction( self.directory, self.basename, work_directory=self.work_directory,
                                              bin=self.bin, input=input )


    def setBinFactor( self, bin ):
        """
        Set the bin factor of the project instance to the value specified by variable
        *bin*. This will set up the appropriate directory names.

        :param bin: The binning factor used in this project.
        
        """

        log.info("Project bin factor set to: %s" %bin)

        self.bin = bin

        # Define the utility folders

        if bin==None:   # The binning is not forced. At 'load', it will be set by the remaining items (reconstruction or projection maps)
            self.align_directory = os.path.join( self.work_directory, ALIGN_DIR )
            self.multser_dir = os.path.join( self.work_directory, ALIGN_DIR, "{0:s}-{1:s}".format(MULTIPLE_SERIES_DIR,self.basename))
            self.filter_directory = os.path.join( self.work_directory, FILTER_DIR )
            self.setup_directory = os.path.join( self.work_directory, SETUP_DIR)
            self.backprojection_directory = os.path.join( self.work_directory, BACKPROJECTION_DIR)
            self.art_directory = os.path.join( self.work_directory, ART_DIR )
            self.contour_directory = os.path.join( self.align_directory, CONTOUR_DIR )
        else:
            self.align_directory = os.path.join( self.work_directory, ALIGN_DIR, "bin%i" %self.bin )
            self.multser_dir = os.path.join( self.work_directory, ALIGN_DIR, "{0:s}-{1:s}-bin{2:}".format(MULTIPLE_SERIES_DIR,self.basename,self.bin))
            self.filter_directory = os.path.join( self.work_directory, FILTER_DIR, "bin%i" %self.bin )
            self.setup_directory = os.path.join( self.work_directory, SETUP_DIR, "bin%i" %self.bin)
            self.backprojection_directory = os.path.join( self.work_directory, BACKPROJECTION_DIR, "bin%i" %self.bin)
            self.art_directory = os.path.join( self.work_directory, ART_DIR, "bin%i" %self.bin )
            self.contour_directory = os.path.join( self.align_directory, CONTOUR_DIR )

          
    def rescale(self, sx, sy, sz, Ox=1, Oy=1, Oz=1):
        """
        This method rescale a project (its reconstruction and all it series).
        
        :param sx: The new pixel size in the x direction.
        :param sy: The new pixel size in the y direction.
        :param sz: The new pixel size in the z direction.
        """

        log.info("Rescale the project by (%.2f,%.2f)" %(sx,sy))

        self.reconstruction.rescale( sx, sy, sz, Ox=Ox, Oy=Oy, Oz=Oz )

        for series in self.series:
            series.rescale(sx, sy, sz, Ox=Ox, Oy=Oy, Oz=Oz)


    def numberOfSeries( self ):
        '''Returns the total number of series contained in this project.'''

        return len(self.series)
    
    
    def numberOfEnabledSeries( self ):
        '''Returns the total number of enabled series in the project'''

        n = 0
        for s in self.series:
            if s.enabled: n += 1

        return n


    def getSeries( self, basename, fromext=False ):
        '''Returns a series from its basename, None if the series does not exist.

        :param serieBasename: The basename of the series to return
        :param fromext: If true the series basename really correspond to its extension
        '''

        if fromext:
            for index,extension in enumerate(self.extensions):
                if extension==basename:
                    return self.series[index]
        else:
            for series in self.series:
                if series.basename==basename: return series

        return None


    def indexOfSeries( self, basename, fromext=False ):
        '''Returns a series index from its basename, or its extension, -1 if the series
        does not exist.

        :param basename: The basename (or the extension) of the series to return
        :param fromext: If true the series basename really correspond to its extension
        '''

        if fromext:
            for index,extension in enumerate(self.extensions):
                if extension==basename:
                    return index
        else:
            for index,series in enumerate(self.series):
                if series.basename==basename:
                    return index

        return -1


    def addSeries( self, series=None, extensionOfSeries=None ):
        """Add a series to this project. It can either added directly for from its
        extension.

        :param series: The series to add.
        :param extensionOfSeries: The extension of the series to add. If it is different of
        None, the series will be constructed from its extension and added on to the project
        regardless of the first parameter *series*.
        """

        if extensionOfSeries==None and series==None: return

        if extensionOfSeries!=None:
            seriesBasename = self.basename + extensionOfSeries
            series = TxBRSerie( self.directory, seriesBasename, work_directory=self.work_directory,
                                input=self.reconstruction.input )

        if self.getSeries(series.basename)!=None: # Do not add identical series
            log.warning("Series '%s' is already in the project" %series.basename)
            return

        self.extensions.append(series.basename[len(self.basename):])
        self.series.append(series)

        log.info("Series '%s' has been added" %series.basename)


    def stackedSeries( self ):
        """
        All the series of this project are stacked into one large series.
        """
        
        log.info('Stack Series %s' %self.basename)

        series = TxBRSerie( self.directory, self.basename, work_directory=self.work_directory, load=False)
        
        # Problem with the rotation axis....

        for s in self.series: series.rotAxis = s.rotAxis

        # The projection object

        order = max([s.projection.approximationOrder() for s in self.series])
        series.projection.approximationOrder(approximationOrder=order)
        
        for s in self.series:
            series.projection.scaling_coefficients = numpy.row_stack([series.projection.scaling_coefficients,s.projection.scaling_coefficients])
            series.projection.x_coefficients = numpy.row_stack([series.projection.x_coefficients,s.projection.x_coefficients])
            series.projection.y_coefficients = numpy.row_stack([series.projection.y_coefficients,s.projection.y_coefficients])
            series.prealignTranslations = numpy.row_stack([series.prealignTranslations,s.prealignTranslations])

        # The reconstruction object

        series.xmin = min([s.xmin for s in self.series])
        series.xmax = max([s.xmax for s in self.series])
        series.ymin = min([s.ymin for s in self.series])
        series.ymax = max([s.ymax for s in self.series])
        series.zmin = min([s.zmin for s in self.series])
        series.zmax = max([s.zmax for s in self.series])

        return series


    def saveAll( self, extension=None ):
        """
        Save the project and all the series it contains.

        :param extension: Adds a post-extension to the configuration file name (after
        the ".txbr" standard one).
        """
        
        log.info('Save Project %s' %self.basename)

        nseries = len(self.series)

        for index in range(nseries):
            self.save( indexOfSerie=index, extension=extension )
            
        if nseries>1: self.save( extension=extension )


    def save( self, indexOfSerie=None, extension=None ):
        """
        Save the series configuration file for series *indexOfSerie* of this project.

        :param indexOfSerie: Index of the series to save.
        :param extension: Adds a post-extension to the configuration file name (after
        the ".txbr" standard one).
        """

        if extension!=None:
            extension = utilities.TXBR_EXTENSION + extension
        else:
            extension = utilities.TXBR_EXTENSION

        extension_bin = extension + ".bin%i" %self.bin

        if self.bin!=None and self.bin!=1: # Rescale to the original pixel size
            self.rescale( 1.0/self.bin, 1.0/self.bin, 1.0/self.bin )
            
        reconstruction = self.reconstruction.copy()

        try:
            series = self.series[indexOfSerie]
            reconstruction.input = series.input
            reconstruction.setOrigin(series.xmin,series.ymin,None)
            reconstruction.setEnd(series.xmax,series.ymax,None)
            log.info('Save Series #%i' %indexOfSerie)
        except TypeError:  # indexOfSeries is None
            series = self.stackedSeries()
            log.info('Save Series Stack %s' %series.basename)

        filename_bin = os.path.join( self.work_directory, series.basename + extension_bin )

        f = open(filename_bin,'w')
        f.write('basename: %s\n' %series.basename)
        f.write('directory: %s\n' %series.directory)
        f.write('\n')
        f.write(reconstruction.toString())
        f.write(series.toString())
        f.close()

        if self.bin!=None and self.bin!=1:
            self.rescale( self.bin, self.bin, self.bin )

        if extension==utilities.TXBR_EXTENSION:

            filename = os.path.join( self.work_directory, series.basename + extension )

            if os.path.exists(filename):
                os.unlink(filename)
#            os.symlink( filename_bin, filename )
            os.symlink( series.basename + extension_bin, filename )


    def validate(self):
        '''Validate the txbr project'''

        log.info("Validate Project")

        if len(self.series)==0: return

        # Check if the number of tracks is the same for each series

        basename, extensions = utilities.extract_series_name( [ s.basename for s in self.series ] )

        trackSet = set([])

        for s in self.series:
            modelFile = s.basename + utilities.TRACK_EXTENSION
            if os.path.lexists(modelFile):
                m = modl.Model(modelFile)
                m.loadFromFile()
                trackSet.add(len(m.objects))
            else:
                trackSet.add(0)

        mosaic_file = self.basename + utilities.MOSAIC_EXTENSION
        if len(trackSet)!=1 and os.path.exists( basename + utilities.MOSAIC_EXTENSION ):
            utilities.mergeMosaicModels( basename, extensions, mosaic_file, keep_constraints_only=False )

        # Validate each series independtly

        for s in self.series: s.validate()


    def __repr__( self):

        rep = "<%s: basename='%s', dir='%s',  wd='%s',  bin='%i' [%i series]>" %(self.__class__, self.basename, self.directory, self.work_directory, self.bin, len(self.series))

        return rep





class Reconstruction(util.Bounds3D):
    '''A reconstruction volume class associated with a TxBR project. It contains the final
    geometry (boundaries) of the reconstructed volume as well as information about on the
    specimen stage. Variable rotAxis is the axis of rotation of the stage for a tilt series.'''

    def __init__( self, directory, basename, work_directory=None, bin=None, input=None ):

        util.Bounds3D.__init__( self )

        self.directory = directory
        self.basename = basename
        self.work_directory = work_directory
        self.alignment_model = ""
        self.input = input
        
        self.sizeOfBlock = 5    # To manage the RAM
        self.bin = None

#        self.origin = util.Point3D(numpy.nan,numpy.nan,numpy.nan)
#        self.end =  util.Point3D(numpy.nan,numpy.nan,numpy.nan)
#        self.increment = util.Vector3D(1.0,1.0,1.0) # default
#
#        self.scale = util.Vector3D(numpy.nan,numpy.nan,numpy.nan)
        
        self.bottomPlane = util.Plane3D(0.0,0.0,1.0,0.0)    # origin should normally belong to the bottom plane
        self.topPlane = util.Plane3D(0.0,0.0,1.0,0.0)    # end should normally belong to the top plane


#    def isUndefined( self ):
#        '''Check if the reconstruction parameters are defined (different from numpy.nan)'''
#
#        p = [ self.origin.x, self.origin.y, self.origin.z,
#              self.end.x, self.end.y, self.end.z,
#              self.increment.x, self.increment.y, self.increment.z,
#              self.scale.x, self.scale.y, self.scale.z ]
#
#        p = numpy.array(p)
#
#        return numpy.any(numpy.isnan(p))

    
    def copy(self):
        
        reconstruction = Reconstruction( self.directory, self.basename, self.work_directory, self.input)
        
        reconstruction.bin = self.bin
        
        reconstruction.alignment_model = self.alignment_model
        
        reconstruction.origin = util.Point3D(self.origin.x,self.origin.y,self.origin.z)
        reconstruction.end = util.Point3D(self.end.x,self.end.y,self.end.z)
        reconstruction.increment = util.Vector3D(self.increment.x,self.increment.y,self.increment.z)
        reconstruction.scale = util.Vector3D(self.scale.x,self.scale.y,self.scale.z)
        reconstruction.bottomPlane = util.Plane3D(self.bottomPlane.a,self.bottomPlane.b,self.bottomPlane.c,self.bottomPlane.d)
        reconstruction.topPlane = util.Plane3D(self.topPlane.a,self.topPlane.b,self.topPlane.c,self.topPlane.d)

        reconstruction.update()
        
        return reconstruction


    def getFileName( self ):
        '''Returns the full path name of the associated reconstruction'''

        bin = self.bin==None and 1 or self.bin

        backprojection_directory = os.path.join( self.work_directory, BACKPROJECTION_DIR, "bin%i" %bin)

        return os.path.join( backprojection_directory, "%s_z_%.1f.out" %(self.basename,self.origin.z) )
    

    def update(self):

        self.nx = int(self.end.x - self.origin.x + 1)
        self.ny = int(self.end.y - self.origin.y + 1)
        self.nz = int(self.end.z - self.origin.z + 1)

        
    def rescale(self, sx, sy, sz, Ox=1, Oy=1, Oz=1):

        log.info("Rescale the reconstruction by (%.2f,%.2f)" %(sx,sy))

        self.origin.x = Ox + (self.origin.x-Ox)/sx
        self.origin.y = Oy + (self.origin.y-Oy)/sy
        self.origin.z = Oz + (self.origin.z-Oz)/sz

        self.end.x = Ox + (self.end.x-Ox)/sx
        self.end.y = Oy + (self.end.y-Oy)/sy
        self.end.z = Oz + (self.end.z-Oz)/sz

        self.origin.x = int(self.origin.x)
        self.origin.y = int(self.origin.y)
        self.origin.z = int(self.origin.z)

        self.end.x = int(self.end.x)
        self.end.y = int(self.end.y)
        self.end.z = int(self.end.z)
        
        # self.increment is kept the same

        self.scale.x *= sx
        self.scale.y *= sy
        self.scale.z *= sz

        self.bottomPlane.a = self.bottomPlane.a + \
                             self.bottomPlane.b*Ox*(1-1.0/sx) + \
                             self.bottomPlane.c*Oy*(1-1.0/sy) + \
                             self.bottomPlane.d*Oz*(1-1.0/sz)
        self.bottomPlane.b /= sx
        self.bottomPlane.c /= sy
        self.bottomPlane.d /= sz

        self.topPlane.a = self.topPlane.a + \
                          self.topPlane.b*Ox*(1-1.0/sx) + \
                          self.topPlane.c*Oy*(1-1.0/sy) + \
                          self.topPlane.d*Oz*(1-1.0/sz)

        self.topPlane.b /= sx
        self.topPlane.c /= sy
        self.topPlane.d /= sz


#    def getFrame( self, full=True ):
#
#        P0 = [self.origin.x,self.origin.y,self.origin.z]
#        P1 = [self.end.x,self.origin.y,self.origin.z]
#        P2 = [self.origin.x,self.end.y,self.origin.z]
#        P3 = [self.origin.x,self.origin.y,self.end.z]
#        P4 = [self.end.x,self.end.y,self.origin.z]
#        P5 = [self.end.x,self.origin.y,self.end.z]
#        P6 = [self.origin.x,self.end.y,self.end.z]
#        P7 = [self.end.x,self.end.y,self.end.z]
#
#        if full:
#            return numpy.column_stack((P0,P1,P2,P3,P4,P5,P6,P7))
#        else:
#            return numpy.column_stack((P0,P7))


    def setOrigin(self,x,y,z):

        util.Bounds3D.setOrigin( self,x,y,z )

#        try:
#            self.origin.x = float(x)
#        except TypeError:
#            pass
#        try:
#            self.origin.y = float(y)
#        except TypeError:
#            pass
#        try:
#            self.origin.z = float(z)
#        except TypeError:
#            pass

        self.bottomPlane.d = self.origin.z


#    def setIncrement(self,x,y,z):
#
#        try:
#            self.increment.x = float(x)
#        except TypeError:
#            pass
#        try:
#            self.increment.y = float(y)
#        except TypeError:
#            pass
#        try:
#            self.increment.z = float(z)
#        except TypeError:
#            pass


    def setEnd(self,x,y,z):

        util.Bounds3D.setEnd( self,x,y,z )
        
#        try:
#            self.end.x = float(x)
#        except TypeError:
#            pass
#        try:
#            self.end.y = float(y)
#        except TypeError:
#            pass
#        try:
#            self.end.z = float(z)
#        except TypeError:
#            pass

        self.topPlane.d = self.end.z


    def setBottomPlane(self,a,b,c,d):

        self.bottomPlane.a = a
        self.bottomPlane.b = b
        self.bottomPlane.c = c
        self.bottomPlane.d = d


    def setTopPlane(self,a,b,c,d):

        self.topPlane.a = a
        self.topPlane.b = b
        self.topPlane.c = c
        self.topPlane.d = d
        

    def getRotation(self):
        '''Rotation around the origin that brings the bottom and top planes parallel to
        the x-y plane'''

        a = (self.bottomPlane.a + self.topPlane.a)/2.0
        b = (self.bottomPlane.b + self.topPlane.b)/2.0
        c = (self.bottomPlane.c + self.topPlane.c)/2.0

        d1 = a**2 + b**2
        d1_sqr_root = numpy.sqrt(d1)

        d2 = a**2 + b**2 + c**2
        d2_sqr_root = numpy.sqrt(d2)

        if d1==0:
            cos_phi = 1.0
            sin_phi = 0.0
        else:
            cos_phi = a/d1_sqr_root
            sin_phi = b/d1_sqr_root

        cos_theta = c/d2_sqr_root
        sin_theta = d1_sqr_root/d2_sqr_root

        rot = numpy.zeros((3,3))

        rot[0,0] = cos_phi*cos_phi*(cos_theta-1.0) + 1.0
        rot[1,0] = cos_phi*sin_phi*(cos_theta-1.0)
        rot[2,0] = -cos_phi*sin_theta

        rot[0,1] = cos_phi*sin_phi*(cos_theta-1.0)
        rot[1,1] = sin_phi*sin_phi*(cos_theta-1.0) + 1.0
        rot[2,1] = -sin_phi*sin_theta

        rot[0,2] = cos_phi*sin_theta
        rot[1,2] = sin_phi*sin_theta
        rot[2,2] = cos_theta

        return rot
    
    
    def getOffset(self):
        """Returns offsets that will be used in the IMOD model file"""
        
        xoffset = 1 - self.origin.x
        yoffset = 1 - self.origin.y
        zoffset = 0 - self.origin.z
        
        return util.Vector3D( xoffset, yoffset, zoffset )


    def __repr__( self ):

        opts = numpy.get_printoptions()
        numpy.set_printoptions(precision=3)

        rep = "<%s: %s>\n" %(self.__class__,self.basename)
        rep += 'x->%f:%f:%f\n' %(self.origin.x,self.increment.x,self.end.x)
        rep += 'y->%f:%f:%f\n' %(self.origin.y,self.increment.y,self.end.y)
        rep += 'z->%f:%f:%f\n' %(self.origin.z,self.increment.z,self.end.z)
        rep += 'alignment: %s\n' %self.alignment_model
        rep += 'input: %s\n' %self.input
        rep += 'blocksize: %i\n' %(self.sizeOfBlock)
        rep += 'scale: %f:%f:%f\n' %(self.scale.x,self.scale.y,self.scale.z)
        rep += 'plane_coeffs1: %f %f %f\n' %(self.bottomPlane.d,self.bottomPlane.a,self.bottomPlane.b)
        rep += 'plane_coeffs2: %f %f %f' %(self.topPlane.d,self.topPlane.a,self.topPlane.b)

        numpy.set_printoptions(**opts)

        return rep

    
    def __str__( self ):

        rep = "<%s: %s x:[%.1f,%.1f] y:[%.1f,%.1f] z:[%.1f,%.1f]  scale:[%.1f,%.1f,%.1f]>" %( self.__class__, self.basename, \
                        self.origin.x, self.end.x, self.origin.y, self.end.y, self.origin.z, self.end.z, \
                        self.scale.x, self.scale.y, self.scale.z )

        return rep


    def toString(self):

        toString = 'x->%f:%f:%f\n' %(self.origin.x,self.increment.x,self.end.x)
        toString += 'y->%f:%f:%f\n' %(self.origin.y,self.increment.y,self.end.y)
        toString += 'z->%f:%f:%f\n' %(self.origin.z,self.increment.z,self.end.z)
        toString += '\n'
        toString += 'alignment: %s\n' %self.alignment_model
        toString += 'input: %s\n' %self.input
        toString += 'blocksize: %i\n' %(self.sizeOfBlock)
        toString += 'scale: %f:%f:%f\n' %(self.scale.x,self.scale.y,self.scale.z)
        toString += '\n'
        toString += 'plane_coeffs1: %f %f %f\n' %(self.bottomPlane.d,self.bottomPlane.a,self.bottomPlane.b)
        toString += 'plane_coeffs2: %f %f %f\n' %(self.topPlane.d,self.topPlane.a,self.topPlane.b)
        toString += '\n'

        return toString
    
    


class Map:
    """This class models a projective polynomial function in 3D.
    It is used to describe projection and trajectory maps in TxBR."""

    def __init__( self, approximationOrder=None, n=None):
        
        self.order = None
        self.approximationOrder( approximationOrder, n )
        self.label = ""

    def approximationOrder( self, approximationOrder=None, n=None ):

        if approximationOrder!=None:
            self.order = approximationOrder
            try:
                numberOfTerms0 = self.numberOfTerms
            except AttributeError:
                if n==None: n=0
                self.numberOfTerms = util.numberOfTerms(approximationOrder)
                self.x_coefficients = numpy.zeros((n,self.numberOfTerms),dtype=float)
                self.y_coefficients = numpy.zeros((n,self.numberOfTerms),dtype=float)
                self.scaling_coefficients = numpy.zeros((n,self.numberOfTerms),dtype=float)
            else:
                self.numberOfTerms = util.numberOfTerms(approximationOrder)
                n = self.numberOfExposures()
                ntail = self.numberOfTerms-numberOfTerms0
                if self.numberOfTerms>numberOfTerms0:
#                    self.x_coefficients.resize((n,self.numberOfTerms))
#                    self.y_coefficients.resize((n,self.numberOfTerms))
#                    self.scaling_coefficients.resize((n,self.numberOfTerms))
                    self.x_coefficients = numpy.resize(self.x_coefficients,(n,self.numberOfTerms))
                    self.y_coefficients = numpy.resize(self.y_coefficients,(n,self.numberOfTerms))
                    self.scaling_coefficients = numpy.resize(self.scaling_coefficients,(n,self.numberOfTerms))

                else:
                    self.x_coefficients = self.x_coefficients[:,:self.numberOfTerms]
                    self.y_coefficients = self.y_coefficients[:,:self.numberOfTerms]
                    self.scaling_coefficients = self.scaling_coefficients[:,:self.numberOfTerms]
            powers_ = util.powerOrder(approximationOrder)
            self.order_X = powers_[0]
            self.order_Y = powers_[1]
            self.order_Z = powers_[2]

            log.debug('Projection Map')
            log.debug(self.order_X)
            log.debug(self.order_Y)
            log.debug(self.order_Z)

        return self.order

    def rescale( self, sx, sy, sz, Ox=1, Oy=1, Oz=1 ):
        """
        Rescale a map.
        """

        log.info("Rescale Map by (%.2f,%.2f,%.2f)" %(sx,sy,sz))

        sx = 1.0/sx
        sy = 1.0/sy
        sz = 1.0/sz
        
        K = numpy.array([[Ox,sx,0.0,0.0],[Oy,0.0,sy,0.0],[Oz,0.0,0.0,sz]],dtype='float')

        scale_tf = util.AffineTransformation3D(K, with_center=True)
        scale_inv_tf = scale_tf.inv()

        tasks = [ [ scale_tf, self.getPolynomialTransformation(index), util.PolynomialTransformation3D(self.order,self.scaling_coefficients[index]), scale_inv_tf ] for index in range(self.numberOfExposures()) ]

        pool = multiprocessing.Pool( processes=PROCESS_POOL_SIZE )

        rescaled_proj_map = pool.map( __rescale_proj_task_star__, tasks)

        pool.close()
        pool.terminate()

        for index,proj_elts in enumerate(rescaled_proj_map):

            scaled_P,scaled_lambda = proj_elts

            coeffs = scaled_P.coeffs()
            self.x_coefficients[index] = coeffs[0,:]
            self.y_coefficients[index] = coeffs[1,:]

            coeffs = scaled_lambda.coeffs()
            self.scaling_coefficients[index]  = coeffs[0,:]


    def numberOfExposures(self):
        
        try:
            return len(self.x_coefficients)
        except AttributeError:
            return 0


    def scaling(self,X,Y,Z,indexOfExposure):
        scaling = 0
        for i in range(self.numberOfTerms):
            scaling += self.scaling_coefficients[indexOfExposure][i]*pow(X,self.order_X[i])*pow(Y,self.order_Y[i])*pow(Z,self.order_Z[i])
        return scaling


    def x(self,X,Y,Z,indexOfExposure):
        x = 0
        for i in range(self.numberOfTerms):
            x += self.x_coefficients[indexOfExposure][i]*pow(X,self.order_X[i])*pow(Y,self.order_Y[i])*pow(Z,self.order_Z[i])
        x = x/self.scaling(X,Y,Z,indexOfExposure)
        return x


    def y(self,X,Y,Z,indexOfExposure):
        y = 0
        for i in range(self.numberOfTerms):
            y += self.y_coefficients[indexOfExposure][i]*pow(X,self.order_X[i])*pow(Y,self.order_Y[i])*pow(Z,self.order_Z[i])
        y = y/self.scaling(X,Y,Z,indexOfExposure)
        return y


    def getAffineTransformation(self, index):

        K = numpy.row_stack((self.x_coefficients[index,:4],self.y_coefficients[index,:4]))

        return util.AffineTransformation3D(K)


    def getPolynomialTransformation(self, index):

        K = numpy.row_stack((self.x_coefficients[index,:],self.y_coefficients[index,:]))

        return util.PolynomialTransformation3D(self.order,K)


    def __repr__( self ):

        opts = numpy.get_printoptions()
        numpy.set_printoptions(precision=2)

        rep = "<%s: (order:%i-number of exposures: %i)>\n" %(self.__class__,self.order,self.numberOfExposures())
        space = "  "
        for index in range(self.numberOfExposures()):
            rep += "%slambda-%i: %s\n" %(space,index,self.scaling_coefficients[index,:])
            rep += "%sx-%i: %s\n" %(space,index,self.x_coefficients[index,:])
            rep += "%sy-%i: %s\n" %(space,index,self.y_coefficients[index,:])

        numpy.set_printoptions(**opts)

        return rep
    

    def toString(self):

        format = ''.join([' %e' for i in range(self.numberOfTerms)]) + '\n'
        toString = ''
        for i in range(self.numberOfExposures()):
            scalingformat = 'lambda-%i:' + format
            toString = toString + scalingformat %tuple([i] + self.scaling_coefficients[i,:].tolist())
            xformat = 'x-%i:' + format
            toString = toString + xformat %tuple([i] + self.x_coefficients[i,:].tolist())
            yformat = 'y-%i:' + format
            toString = toString + yformat %tuple([i] + self.y_coefficients[i,:].tolist())
        return toString
        



class ProjectionMap(Map):
    '''The ProjectionMap class is used to describe the projection maps in TxBR'''

    def __init__( self, approximationOrder=None, n=None ):
        
        Map.__init__( self, approximationOrder, n )


    def __str__( self ):

        return "<Projection Map: (order:%i-number of exposures: %i)>" %(self.order,self.numberOfExposures())




class TrajectoryMap:

    def __init__(self):
        self.order = -1
        self.X_coefficients = []
        self.Y_coefficients = []
        self.Scaling_coefficients = []
        

    def approximationOrder(self,approximationOrder=None):
        if approximationOrder!=None:
            self.approximationOrder = approximationOrder
            self.numberOfTerms = util.numberOfTerms(approximationOrder)
            powers_ = util.powerOrder(approximationOrder)
            self.order_x = powers_[0]
            self.order_y = powers_[1]
            self.order_Z = powers_[2]
        return self.order


    def numberOfExposures(self):
        
        return len(self.X_coefficients)


    def rescale(self, sx, sy, sz, Ox=1, Oy=1, Oz=1):

        log.warning("Rescale function not implemented for trajectory maps")


    def Scaling(self,x,y,Z,indexOfExposure):
        Scaling = 0
        for i in range(self.numberOfTerms):
            Scaling += self.Scaling_coefficients[indexOfExposure][i]*pow(x,self.order_x[i])*pow(y,self.order_y[i])*pow(Z,self.order_Z[i])
        return Scaling


    def X(self,x,y,Z,indexOfExposure):
        X = 0
        for i in range(self.numberOfTerms):
            X += self.X_coefficients[indexOfExposure][i]*pow(x,self.order_x[i])*pow(y,self.order_y[i])*pow(Z,self.order_Z[i])
        X = X/self.scaling(x,y,Z,indexOfExposure)
        return X


    def Y(self,x,y,Z,indexOfExposure):
        Y = 0
        for i in range(self.numberOfTerms):
            Y += self.Y_coefficients[indexOfExposure][i]*pow(x,self.order_x[i])*pow(y,self.order_y[i])*pow(Z,self.order_Z[i])
        Y = Y/self.scaling(x,y,Z,indexOfExposure)
        return Y




class TxBRSerie:
    '''A class to modelize a EM tilt series.'''

    def __init__( self, directory, basename, work_directory=None, bin=None, load=False, input=INPUT ):

        self.directory = directory
        self.basename = basename
        
        if work_directory==None:
            self.work_directory = directory
        else:
            self.work_directory = work_directory
        
        self.enabled = True
        self.input = input    # None, 'preali' or 'st'
        
        # Scaling parameters will be ultimately loaded from the ".txbr" configuration file
        self.sx = 1.0   # Default pixel size in the x direction (micrograph & volume)
        self.sy = 1.0   # Default pixel size in the y direction (micrograph & volume)
        self.sz = 1.0   # Default pixel size in the z direction

        self.xmin = numpy.nan
        self.ymin = numpy.nan
        self.zmin = numpy.nan
        self.xmax = numpy.nan
        self.ymax = numpy.nan
        self.zmax = numpy.nan
        
        self.rotPoint = [0.0,0.0,0.0]
        self.rotAxis = [0.0,1.0,0.0]
        self.sampleOrientation = [0.0,0.0,0.0]

        self.stack = utilities.loadStack( self.directory, self.basename, workDirectory=self.work_directory, scope=None, bin=bin )

        if self.stack==None:
            log.warning("No data stack for tilt series %s" %self.basename)
        else:
            self.sx,self.sy = self.stack.getImageScale()
            self.sz = max(self.sx,self.sy)

        stPath = os.path.join(directory, basename + '.st')
        prexgPath = os.path.join(directory, basename + '.prexg')
        prealiPath = os.path.join(directory, basename + '.preali')
        
        #if self.input=='st' and os.path.exists(stPath) and os.path.exists(prexgPath):
        if self.input=='st' and os.path.exists(stPath):
            self.input = 'st'
            self.file = mrc.MRCFile(stPath)
        elif os.path.exists(prealiPath): # Otherwise, automatically switch to preali
            self.input = 'preali'
            self.file = mrc.MRCFile(prealiPath)
        else:
            log.warning("The input data files are not available for processing!")
            self.input = None
            self.file = None

#        mrkPath = os.path.join(self.work_directory, basename + '.mrk')

#
#        if not os.path.exists(mrkPath):
#            utilities.makeMarkerModel( directory, basename, work_directory=self.work_directory )
#
#        trkPath = os.path.join(self.work_directory, basename + '.trk')
#
#        if os.path.lexists(trkPath): os.unlink(trkPath)
#        os.symlink(os.path.basename(mrkPath),trkPath)

        self.tiltAngles = []
        self.disabledTiltAngles = []
        self.projection = ProjectionMap()
        self.trajectory = TrajectoryMap()
        self.prealignTranslations = numpy.zeros((0,2))

       # if load: self.load()


    def numberOfExposures(self):

        numberOfAngles = len(self.tiltAngles)
        numberOfExposures = self.projection.numberOfExposures()

        return max(numberOfAngles,numberOfExposures)


    def getReconstructionFileName( self ):
        '''Returns the full path name of the associated reconstruction to this specific series'''

        return os.path.join(self.directory,"%s_z_%.1f.out" %(self.basename,self.zmin))


    def validate(self):
        """The validate method makes sure of the conformity betwen the metadata and
        the actual data if it is available.
        It will eventually set the bin factor in the stack of images so they match."""
        
        # Make sure the stack scales (equivalently the bin factor) is matching the scales
        # of the series

        log.info("Validate the series %s against its metadata" %self)

        sx0,sy0 = self.stack.getImageScale()

        binx,biny = round(self.sx*self.stack.bin/sx0),round(self.sy*self.stack.bin/sy0)

        log.info("(stack<->metadata)  sx: %.2f<->%.2f    sy: %.2f<->%.2f" %(sx0,self.sx,sy0,self.sy))

        bin = int(max(binx,biny))

        if bin!=1: self.stack.setBinFactor( bin ) # do not overwrite the stack information if bin==1

        # Make sure the number of tilts match between stack and the metadata

        if not self.stack!=None and self.stack.getNumberOfImages!=len(self.tiltAngles):
            raise SystemError, "Number of images between the data stack and its metadata is different"

        if self.file!=None and self.file.nz!=len(self.tiltAngles):
            raise SystemError, "Number of tilts in the input MRC stack and the raw tilt file are different"


    def rescaleForReconstruction( self, reconstruction ):
        '''Rescale the series to the same scale as the reconstruction object'''

        log.info("Rescale series %s to reconstruction %s" %(self.basename,reconstruction))

        try:

            if reconstruction.isUndefined(): raise ValueError()

            sx_new = reconstruction.scale.x
            sy_new = reconstruction.scale.y
            sz_new = reconstruction.scale.z

            sx = sx_new/self.sx
            sy = sy_new/self.sy
            sz = sz_new/self.sz

            eps = 1e-4
            if abs(1.0-sx)>eps or abs(1.0-sy)>eps or abs(1.0-sz)>eps:
                self.rescale(sx,sy,sz)
            else:
                self.validate()

        except: # The reconstruction object is not set

            log.warning("Not able to rescale to reconstruction %s" %reconstruction)
            
            pass


    def rescale( self, sx, sy, sz, Ox=1, Oy=1, Oz=1 ):
        """
        Rescale a series (boundaries, prealignment, projection and trajectory maps).
        """

        log.info("Rescale series %s (scale: [%.1f,%.1f,%.1f])" %(self.basename,sx,sy,sz))

        try: # Rescale the box of the series

            self.xmin = Ox + (self.xmin-Ox)/sx
            self.xmax = Ox + (self.xmax-Ox)/sx
            self.ymin = Oy + (self.ymin-Oy)/sy
            self.ymax = Oy + (self.ymax-Oy)/sy

            self.xmin = int(self.xmin)
            self.xmax = int(self.xmax)
            self.ymin = int(self.ymin)
            self.ymax = int(self.ymax)

        except AttributeError:

            pass

        except ValueError:

            pass

        # Rescale the projection map and the trajectory point
        # The assumption here is that the prealignment contribution is already scaled

        self.shiftPrealignTransform(eps=-1)

        if self.projection!=None:
            self.projection.rescale( sx, sy, sz, Ox=Ox, Oy=Oy, Oz=Oz )

        if self.trajectory!=None:
            self.trajectory.rescale( sx, sy, sz, Ox=Ox, Oy=Oy, Oz=Oz )

        self.shiftPrealignTransform(eps=+1)

        self.sx *= sx
        self.sy *= sy
        self.sz *= sz

        self.validate()


    def shiftPrealignTransform( self, eps=1 ):
        '''Add (default behavior) or remove the prealignment contribution (usually
        evaluated from a cross-correlation scheme) for the projection map'''

        if self.input=='st':
            sign = numpy.sign(eps)
            for itilt in range(self.projection.numberOfExposures()):
                T = self.prealignTranslations[itilt,:]
                self.projection.x_coefficients[itilt][0] += sign*T[0]
                self.projection.y_coefficients[itilt][0] += sign*T[1]


    def getTransferCoordinatesElements(self):
        '''Returns the transformations for changing coordinates from the
        laboratory frame (or microscope/camera frame, given by (ex,ey,ez))
        to a reference frame where the "rotation axis" is along the second
        direction (u2), and the first direction is perpendicular to ez.
        Returns a tuple (T,M), containing the translation and linear
        transformation that should be used for the coordinates change.
        New coordinates of a point are given by T + M x, where x represent
        its coordinates in the laboratory frame.
        '''

        ex = numpy.array([1.0,0.0,0.0])
        ey = numpy.array([0.0,1.0,0.0])
        ez = numpy.array([0.0,0.0,1.0])

        u2 = numpy.asarray(self.rotAxis)   # The image of ey
        u2 = u2/numpy.linalg.norm(u2)

        u1 = numpy.cross(ez,u2)
        u1 = u1/numpy.linalg.norm(u1)

        u3 = numpy.cross(u1,u2)

        M = numpy.column_stack((u1,u2,u3))
        M = numpy.linalg.inv(M)

        nx,ny = self.dimensions()
        centerOfImage = numpy.asarray((nx/2.0,ny/2.0,0.0))
        fixedPoint = centerOfImage
        
        T = fixedPoint - numpy.dot(M,fixedPoint)

        return (T,M)


    def getTransferedCoordinatesFrame(self):

        T,M = self.getTransferCoordinatesElements()

        O = numpy.array([self.origin.x,self.origin.y,self.origin.z])
        E = numpy.array([self.end.x,self.end.y,self.end.z])

        O_tf = T + numpy.dot(M,O)
        E_tf = T + numpy.dot(M,E)

        return (O_tf.tolist(),E_tf.tolist())


    def getFilteringAngle(self):

        axis = numpy.asarray(self.rotAxis)
        axis = axis/numpy.sqrt(numpy.dot(axis,axis))

        angle = - numpy.arctan(axis[0]/axis[1])

        return angle


    def setResidualTraceAngle(self,angle):

        self.residualTraceAngle = angle


    def setSampleOrientation(self,phi):
        '''Variable phi: a numpy array containing 3 angles to specify the
        sample orientation of the tilt axis of this series.
        '''

        self.sampleOrientation = phi


    def getSampleOrientation(self):

        return self.sampleOrientation
    
    
    def setRelativeReferenceTransform( self, relativeReferenceTransform ):

        self.relativeReferenceTransform = relativeReferenceTransform


    def getRelativeReferenceTransform(self):

        try:
            
            return self.relativeReferenceTransform
        
        except AttributeError:
            
            nx,ny = self.dimensions()
            centerOfImage = (nx/2.0,ny/2.0,0.0)
        
            # Fixed point: corresponds to a point in the volume (at Z=0) whose projection 
            # would be the image center at zero tilt
            indexref = self.indexOfReferenceExposure()
            t0 = numpy.array((self.projection.x_coefficients[indexref][0],
                              self.projection.y_coefficients[indexref][0],
                              0.0))
            centerOfVolume = centerOfImage - t0

            c = numpy.cos(self.sampleOrientation)
            s = numpy.sin(self.sampleOrientation)
            
            M = [ [ c[1]*c[2], c[1]*s[2], s[1] ], \
                  [ - s[0]*s[1]*c[2] - c[0]*s[2], -s[0]*s[1]*s[2] + c[0]*c[2], s[0]*c[1] ], \
                  [ - c[0]*s[1]*c[2] + s[0]*s[2], -c[0]*s[1]*s[2] - s[0]*c[2], c[0]*c[1] ] \
                  ]
            M = numpy.array(M)
    
            T = centerOfVolume - numpy.dot(M,centerOfImage)
            
            return util.AffineTransformation3D(numpy.column_stack((T,M)))
    
        return None


    def getSampleTransferCoordinatesElements(self):
        '''Returns the transformations for changing coordinates from the
        sample frame to the reference frame where the "rotation axis" is along the second
        direction (u2), and the first direction is perpendicular to ez.
        Returns a tuple (T,M), containing the translation and linear
        transformation that should be used for the coordinates change.
        New coordinates of a point are given by T + M x, where x represent
        its coordinates in the sample frame.
        '''

        c = numpy.cos(self.sampleOrientation)
        # To check
        #s = - numpy.sin(self.sampleOrientation)
        s = numpy.sin(self.sampleOrientation)

        ST = []

        ST.append([ c[1]*c[2], c[1]*s[2], s[1] ])
        ST.append([ - s[0]*s[1]*c[2] - c[0]*s[2], -s[0]*s[1]*s[2] + c[0]*c[2], s[0]*c[1] ])
        ST.append([ - c[0]*s[1]*c[2] + s[0]*s[2], -c[0]*s[1]*s[2] - s[0]*c[2], c[0]*c[1] ])

        nx,ny = self.dimensions()
        fixedPoint = (nx/2.0,ny/2.0,0.0)
        fixedPoint = numpy.asarray(fixedPoint)

        T = fixedPoint - numpy.dot(ST,fixedPoint)

        return (T,ST)


    def dimensions(self):
        '''Returns the x-y dimensions in pixel of the source images.'''


        return self.stack.getImageSize()

        stackPath = os.path.join(self.directory, self.basename + '.preali')
        fidPath = os.path.join(self.directory, self.basename + '.fid')
        trkPath = os.path.join(self.directory, self.basename + '.trk')

        if os.path.exists(stackPath):
            return (self.file.nx,self.file.ny)
        elif os.path.exists(fidPath):
            (xmax,ymax,zmax) = modl.getDimensions(fidPath)
            return (xmax,ymax)
        elif os.path.exists(trkPath):
            (xmax,ymax,zmax) = modl.getDimensions(trkPath)
            return (xmax,ymax)

        raise ValueError
        
        
    def getScales(self):
        '''Returns the scale (in Angstrom per pixel) in the x and y direction of the
        micrographs'''
        
        fidPath = os.path.join(self.directory, self.basename + '.fid')
        trkPath = os.path.join(self.directory, self.basename + '.trk')

        try:
            sx,sy = self.sx,self.sy # Eventualy read from the txbr file
        except AttributeError:
            sx,sy = 1.0,1.0

        if self.file!=None:
            sx, sy =  float(self.file.sx), float(self.file.sy)
        elif os.path.exists(fidPath):
            tx, ty, tz, sx, sy, sz, rx, ry, rz = modl.getImgRefParameters(fidPath)
        elif os.path.exists(trkPath):
            tx, ty, tz, sx, sy, sz, rx, ry, rz = modl.getImgRefParameters(trkPath)
        
        return sx, sy


    def indexOfReferenceExposure(self):
        '''Returns the index of the reference exposure.'''
        
        indexOfReference = -1;
        referenceAngle = None
        for index in range(len(self.tiltAngles)):
            angle = self.tiltAngles[index]
            if referenceAngle==None or abs(angle)<abs(referenceAngle):
                indexOfReference = index
                referenceAngle = angle;
        return indexOfReference
    
    
    def getSourceFrame(self, full=True ):
        
        nx,ny = self.dimensions()
        
        P0 = [ 0, 0 ]
        P1 = [ nx, 0 ]
        P2 = [ 0, ny ]
        P3 = [ nx, ny ]
        
        if full:
            return numpy.column_stack((P0,P1,P2,P3))
        else:
            return numpy.column_stack((P0,P3)) 
        
        #return numpy.array([[0,nx],[0,ny]])


    def getSubReconstruction( self, bottomPlane=None, topPlane=None ):

        reconstruction = Reconstruction( os.path.abspath(self.directory), self.basename, self.work_directory )

        if self.stack!=None:
            reconstruction.bin = self.stack.bin
        else:
            reconstruction.bin = 1

        reconstruction.setOrigin(self.xmin,self.ymin,self.zmin)
        reconstruction.setEnd(self.xmax,self.ymax,self.zmax)

        reconstruction.scale = util.Vector3D(self.sx,self.sy,self.sz)

        if bottomPlane!=None:
            reconstruction.bottomPlane = util.Plane3D( bottomPlane.a, bottomPlane.b, bottomPlane.c, bottomPlane.d )
        else:
            reconstruction.bottomPlane = util.Plane3D( self.zmin, 0.0, 0.0, 0.0 )

        if bottomPlane!=None:
            reconstruction.topPlane = util.Plane3D( topPlane.a, topPlane.b, topPlane.c, topPlane.d )
        else:
            reconstruction.topPlane = util.Plane3D( self.zmax, 0.0, 0.0, 0.0 )
            
        reconstruction.update()

        return reconstruction


    def getDestinationFrame( self, full=True ):
        '''full=False returns the diagonal'''
        
        P0 = [self.xmin,self.ymin,self.zmin]
        P1 = [self.xmax,self.ymin,self.zmin]
        P2 = [self.xmin,self.ymax,self.zmin]
        P3 = [self.xmin,self.ymin,self.zmax]
        P4 = [self.xmax,self.ymax,self.zmin]
        P5 = [self.xmax,self.ymin,self.zmax]
        P6 = [self.xmin,self.ymax,self.zmax]
        P7 = [self.xmax,self.ymax,self.zmax]

        if full:
            return numpy.column_stack((P0,P1,P2,P3,P4,P5,P6,P7))
        else:
            return numpy.column_stack((P0,P7))        


    def getTrackingModel(self):
        """Returns the file path where the marker are stored"""

        align_dir = os.path.join( self.work_directory, ALIGN_DIR, "bin%i" %self.stack.bin )

        mrkPath = os.path.join(align_dir, self.basename + utilities.MARKER_EXTENSION)
        trkPath = os.path.join(align_dir, self.basename + utilities.TRACK_EXTENSION)

        if not os.path.lexists(mrkPath):
            utilities.makeMarkerModel(self.directory, self.basename, work_directory=align_dir)

        if os.path.lexists(trkPath):
            os.unlink(trkPath)
            
        os.symlink(os.path.basename(mrkPath), trkPath)
        
        return modl.Model(trkPath)


    def nameOfFile(self,type):
        
        extension_map = { 'fiducial':'.fid', 'marker':'.mrk', 'track':'.trk' }
        directory_map = { 'fiducial':self.directory, 'marker':self.work_directory, 'track':self.work_directory }
        
        return os.path.join( directory_map[type], self.basename + extension_map[type] )
    

    def __eq__( self, other ):

        if not isinstance(other, TxBRSerie): return False

        return self.basename!=other.basename and self.directory!=other.directory and self.work_directory!=other.work_directory


    def __repr__( self ):

        repr = "<%s: basename='%s', dir='%s', wd='%s', ntilt=%i, order=%i, scale=(%.3f,%.3f) frame=(%.2f:%.2f,%.2f:%.2f,%.2f:%.2f)>" %(self.__class__,self.basename,self.directory,self.work_directory,self.numberOfExposures(),self.projection.approximationOrder(),self.sx,self.sy,self.xmin,self.xmax,self.ymin,self.ymax,self.zmin,self.zmax)

        return repr

    def __str__( self ):

        repr = "<%s: basename='%s', dir='%s', wd='%s'>" %( self.__class__, self.basename, self.directory, self.work_directory )

        return repr


    def toString(self):
        '''String representation of a series'''

        toString = 'Rotation Axis:[%f,%f,%f]\n' %(self.rotAxis[0],self.rotAxis[1],self.rotAxis[2])
        toString += '\n'
        toString += 'number of tilts: %i\n\n' %self.numberOfExposures()
        toString += 'projection approximation order: %i\n\n' %self.projection.approximationOrder()
        toString += self.projection.toString()

        return toString
